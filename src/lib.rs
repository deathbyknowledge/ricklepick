use std::io::Read;

use value::Value;
use vm::{Extension, VM};

mod op;
pub mod value;
mod vm;

pub struct Parser<'a> {
    vm: VM<'a>,
}

impl<'a> Parser<'a> {
    pub fn from(buf: &'a mut dyn Read) -> Self {
        Self { vm: VM::from(buf) }
    }

    pub fn load(&mut self, buf: &'a mut dyn Read) {
        self.vm = VM::from(buf);
    }

    pub fn add_extension(&mut self, module: &str, name:&str, ext: Extension) {
        self.vm.load_extension(module, name, ext);
    }

    pub fn parse(&mut self) -> Value {
        loop {
            if !self.vm.step() {
                return self.vm.result().expect("did not expect an error tbh");
            }
        }
    }
}

mod tests {
    #[test]
    fn it_works() {
        // (1, 2, 3, 4, (5, 6, 7), 'Test', ('This is just a test.', [2, 4, 6, 8]), 'One', 'Two', 'Three')

        use std::io::BufReader;

        use crate::Parser;
        let file: [u8; 0x5F] = [
            0x80, 0x04, 0x95, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x4b, 0x01,
            0x4b, 0x02, 0x4b, 0x03, 0x4b, 0x04, 0x4b, 0x05, 0x4b, 0x06, 0x4b, 0x07, 0x87, 0x94,
            0x8c, 0x04, 0x54, 0x65, 0x73, 0x74, 0x94, 0x8c, 0x14, 0x54, 0x68, 0x69, 0x73, 0x20,
            0x69, 0x73, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x61, 0x20, 0x74, 0x65, 0x73, 0x74,
            0x2e, 0x94, 0x5d, 0x94, 0x28, 0x4b, 0x02, 0x4b, 0x04, 0x4b, 0x06, 0x4b, 0x08, 0x65,
            0x86, 0x94, 0x8c, 0x03, 0x4f, 0x6e, 0x65, 0x94, 0x8c, 0x03, 0x54, 0x77, 0x6f, 0x94,
            0x8c, 0x05, 0x54, 0x68, 0x72, 0x65, 0x65, 0x94, 0x74, 0x94, 0x2e,
        ];

        let mut reader = BufReader::new(&file[..]);
        let result = Parser::from(&mut reader).parse();
        assert_eq!(result.to_string(), "(1, 2, 3, 4, (5, 6, 7), 'Test', ('This is just a test.', [2, 4, 6, 8]), 'One', 'Two', 'Three')");
    }
}
